# 1. 背景

**有同学可能会说，现在都上云了，服务的动态伸缩应该是特别简单的吧，如果我们发现流量特别大的时候，自动扩容机器到可以支撑目标QPS那不就不需要限流了吗？**

> - 扩容是需要时间。扩容简单来说就是搞一个新的机器，然后重新发布代码，做java的同学应该是知道发布成功一个代码的时间一般不是以秒级计算，而是以分钟级别计算，有时候你扩容完成，说不定流量尖峰都过去了。
> - 扩容到多少是个特别复杂的问题。扩容几台机器这个是比较复杂的，需要大量的压测计算，以及整条链路上的一个扩容，如果扩容了你这边的机器之后，其他团队的机器没有扩容可能最后还是有瓶颈这个也是一个问题。

# 2. 计数器算法

## 2.1 实现

这个算法比较简单粗暴，我们只需要一个累加变量，然后每隔一秒钟去刷新这个累加变量，然后再判断这个累加变量是否大于我们的最大QPS。

```java
    int curQps = 0;
    long lastTime = System.currentTimeMillis();
    int maxQps = 100;
    Object lock = new Object();
    boolean check(){
        synchronized (lock){
            long now = System.currentTimeMillis();
            if (now - lastTime > 1000){
                lastTime = now;
                curQps = 0;
            }
            curQps++;
            if (curQps > maxQps){
                return false;
            }
        }
        return true;
    }
```

## 2.2 缺陷

如果我们最大的qps是100，在0.99秒的时候来了100个请求，然后在1.01秒的时候又来了100个请求，这个是可以通过我们的程序的，但是我们其实在0.03秒之内通过了200个请求，这个肯定不符合我们的预期，因为很有可能这200个请求直接就会将我们机器给打挂。

# 3. 滑动窗口计数器

![img](https://ask.qcloudimg.com/http-save/yehe-5397975/rulsiz2y6t.png?imageView2/2/w/1620)



如上图所示，我们将1s的普通计数器，分成了5个200ms，我们统计的当前qps都需要统计最近的5个窗口的所有qps，再回到刚才的问题，0.99秒和1.01秒其实都在我们的最近5个窗口之内，所以这里不会出现刚才的临界的突刺问题。

其实换个角度想，我们普通的计数器其实就是窗口数量为1的滑动窗口计数器，只要我们分的窗口越多，我们使用计数器方案的时候统计就会越精确，但是相对来说维护的窗口的成本就会增加，等会我们介绍sentinel的时候会详细介绍他是怎么实现滑动窗口计数的。

# 4. 漏斗算法

![img](https://ask.qcloudimg.com/http-save/yehe-5397975/9hew9qx450.png?imageView2/2/w/1620)

在漏斗算法中我们需要关注漏桶和匀速流出，不论流量有多大都会先到漏桶中，然后以均匀的速度流出。如何在代码中实现这个匀速呢？比如我们想让匀速为100q/s，那么我们可以得到每流出一个流量需要消耗10ms，类似一个队列，每隔10ms从队列头部取出流量进行放行，而我们的队列也就是漏桶，当流量大于队列的长度的时候，我们就可以拒绝超出的部分。

漏斗算法同样的也有一定的缺点：无法应对突发流量(和上面的临界突刺不一样，不要混淆)。比如一瞬间来了100个请求，在漏桶算法中只能一个一个的过去，当最后一个请求流出的时候时间已经过了一秒了，所以漏斗算法比较适合请求到达比较均匀，需要严格控制请求速率的场景。

# **5 .令牌桶算法**

为了解决突发流量情况，我们可以使用令牌桶算法，如下图所示：

![img](https://ask.qcloudimg.com/http-save/yehe-5397975/cu3s4uu06h.png?imageView2/2/w/1620)

这个图上需要关注三个阶段：

- 生产令牌：我们在这里同样的还是假设最大qps是100，那么我们从漏斗的每10ms过一个流量转化成每10ms生产一个令牌，直到达到最大令牌。
- 消耗令牌：我们每一个流量都会消耗令牌桶，这里的消耗的规则可以多变，既可以是简单的每个流量消耗一个令牌，又可以是根据不同的流量数据包大小或者流量类型来进行不同的消耗规则，比如查询的流量消耗1个令牌，写入的流量消耗2个令牌。
- 判断是否通过：如果令牌桶足够那么我们就允许流量通过，如果不足够可以等待或者直接拒绝，这个就可以采用漏斗那种用队列来控制。























